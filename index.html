<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Blur Tool</title>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api/dist/face-api.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        color: #333;
        }

        .container {
            width: 70%;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            min-height: 100vh;
        display: flex;
        flex-direction: column;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr;
            gap: 2rem;
            align-items: stretch;
            justify-items: center;
        }

        @media (min-width: 768px) {
            .main-content {
                grid-template-columns: 1fr 1fr;
                gap: 3rem;
                align-items: stretch;
                justify-items: stretch;
            }
        }

        .image-section {
            background: white;
            border-radius: 16px;
            padding: 2rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            min-height: 500px;
        display: flex;
        flex-direction: column;
            width: 100%;
        }

        .image-container {
            flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
            border: 2px dashed #e2e8f0;
            border-radius: 12px;
            position: relative;
            min-height: 300px;
            transition: all 0.3s ease;
        }

        .image-container.drag-over {
            border-color: #667eea;
            background: #f8fafc;
        }

        .image-container.has-image {
            border: none;
        padding: 0;
      }

      #imageCanvas {
        max-width: 100%;
        max-height: 100%;
            border-radius: 8px;
        cursor: crosshair;
      }

      .placeholder {
        text-align: center;
            color: #64748b;
      }

      .placeholder svg {
            width: 4rem;
            height: 4rem;
        margin-bottom: 1rem;
            color: #cbd5e1;
      }

        .placeholder h3 {
        font-size: 1.25rem;
            margin-bottom: 0.5rem;
            color: #334155;
        }

        .placeholder p {
            font-size: 0.9rem;
            color: #64748b;
        }

        .controls-section {
            background: white;
            border-radius: 16px;
            padding: 2rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            min-height: 500px;
        display: flex;
        flex-direction: column;
            width: 100%;
        }

        .control-group {
            margin-bottom: 1.5rem;
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .control-group:last-child {
            margin-bottom: 0;
            flex: 0;
        }

        .control-label {
            display: block;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #334155;
            font-size: 0.9rem;
        }

        .btn {
            display: inline-flex;
        align-items: center;
        justify-content: center;
            padding: 0.75rem 1rem;
            border: none;
            border-radius: 8px;
        font-weight: 500;
            font-size: 0.9rem;
        cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            gap: 0.5rem;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #f1f5f9;
            color: #475569;
            border: 1px solid #e2e8f0;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #e2e8f0;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #dc2626;
        }

        .btn-group {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .btn-group .btn {
            flex: 1;
            min-width: 120px;
        }

      .radio-group {
        display: flex;
            gap: 1rem;
            margin-bottom: 0.5rem;
      }

      .radio-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .radio-item input[type="radio"] {
            width: 16px;
            height: 16px;
            accent-color: #667eea;
        }

        .slider-container {
        position: relative;
      }

      .slider {
        width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e2e8f0;
        outline: none;
            -webkit-appearance: none;
      }

      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
            width: 20px;
            height: 20px;
        border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      }

      .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
        border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .slider-value {
            position: absolute;
            right: 0;
            top: -25px;
            font-size: 0.8rem;
            color: #64748b;
            font-weight: 500;
        }

        .error-message {
            background: #fef2f2;
            color: #dc2626;
            padding: 0.75rem;
            border-radius: 8px;
            font-size: 0.9rem;
            margin-bottom: 1rem;
            border: 1px solid #fecaca;
        }

        .processing-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #e2e8f0;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .drag-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(102, 126, 234, 0.1);
            border: 3px dashed #667eea;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            pointer-events: none;
        }

        .drag-overlay-content {
            background: white;
            padding: 2rem;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
        }

        .drag-overlay-content svg {
            width: 3rem;
            height: 3rem;
            margin-bottom: 1rem;
            color: #667eea;
        }

      .hidden {
        display: none !important;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
            border: 0;
        }

        @media (max-width: 767px) {
            .container {
                width: 95%;
                padding: 1rem;
            }

            .header h1 {
                font-size: 2rem;
            }

            .main-content {
                gap: 1rem;
            }

            .image-section,
            .controls-section {
                padding: 1rem;
                min-height: 400px;
            }

            .btn-group {
                flex-direction: column;
            }

            .btn-group .btn {
                min-width: auto;
            }
        }

        @media (max-width: 1024px) {
            .container {
                width: 85%;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
        <header class="header">
            <h1>Face Blur Tool</h1>
            <p>Protect privacy with AI-powered face detection and blurring</p>
        </header>

        <div class="main-content">
            <div class="image-section">
                <div id="imageContainer" class="image-container">
                    <canvas id="imageCanvas" class="hidden"></canvas>
        <div id="placeholder" class="placeholder">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                            <polyline points="17 8 12 3 7 8"/>
                            <line x1="12" x2="12" y1="3" y2="15"/>
          </svg>
                        <h3>Drop an image here</h3>
                        <p>Drag & drop, paste, or click to upload</p>
        </div>
                    <div id="processingOverlay" class="processing-overlay hidden">
                        <div class="spinner"></div>
                    </div>
                </div>
          </div>

            <div class="controls-section">
                <div id="errorDisplay" class="error-message hidden"></div>

                <div class="control-group">
                    <label class="control-label">Upload Image</label>
                    <div class="btn-group">
                        <input id="imageUpload" type="file" accept="image/*" class="hidden">
                        <button id="uploadBtn" class="btn btn-primary">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                <polyline points="17 8 12 3 7 8"/>
                                <line x1="12" x2="12" y1="3" y2="15"/>
              </svg>
                            Upload Image
            </button>
                        <button id="resetBtn" class="btn btn-secondary">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
                                <path d="M21 3v5h-5"/>
                                <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
                                <path d="M3 21v-5h5"/>
              </svg>
              Reset
            </button>
                    </div>
          </div>

          <div class="control-group">
            <label class="control-label">Blur Type</label>
            <div class="radio-group">
              <div class="radio-item">
                            <input type="radio" id="gaussian" name="blurType" value="gaussian">
                <label for="gaussian">Gaussian</label>
              </div>
              <div class="radio-item">
                            <input type="radio" id="pixelate" name="blurType" value="pixelate" checked>
                <label for="pixelate">Pixelate</label>
              </div>
            </div>
          </div>

          <div class="control-group">
                    <label class="control-label">Blur Intensity</label>
                    <div class="slider-container">
                        <input type="range" id="blurSlider" min="0" max="50" value="20" step="1" class="slider">
                        <span class="slider-value" id="blurValue">20px</span>
                    </div>
          </div>

          <div class="control-group">
                    <label class="control-label">Detection Mode</label>
                    <div class="btn-group">
                        <button id="autoDetectBtn" class="btn btn-primary">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 7V5a2 2 0 0 1 2-2h2"/>
                                <path d="M17 3h2a2 2 0 0 1 2 2v2"/>
                                <path d="M21 17v2a2 2 0 0 1-2 2h-2"/>
                                <path d="M7 21H5a2 2 0 0 1-2-2v-2"/>
                                <path d="M8 14s1.5 2 4 2 4-2 4-2"/>
                                <circle cx="12" cy="10" r="2"/>
                </svg>
                            Auto Detect
              </button>
                        <button id="manualSelectBtn" class="btn btn-secondary">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="m4 4 7.07 17 2.51-7.31L17 11.07 4 4z"/>
                                <path d="m13 13 6 6"/>
                </svg>
                Manual Select
              </button>
            </div>
          </div>

                <div class="control-group">
                    <button id="clearManualBtn" class="btn btn-danger hidden">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 6h18"/>
                            <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/>
                            <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/>
                        </svg>
                        Clear Selections
          </button>
                </div>

                <div class="control-group">
                    <div class="btn-group">
                        <button id="applyBlurBtn" class="btn btn-primary">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="3"/>
                                <path d="M12 1v6m0 6v6"/>
                                <path d="m21 12-6 0m-6 0-6 0"/>
                            </svg>
                            Apply Blur
                        </button>
                        <button id="downloadBtn" class="btn btn-secondary">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                <polyline points="7 10 12 15 17 10"/>
                                <line x1="12" x2="12" y1="15" y2="3"/>
              </svg>
              Download
            </button>
          </div>
        </div>
      </div>
    </div>
    </div>

    <!-- Drag Overlay -->
    <div id="dragOverlay" class="drag-overlay hidden">
        <div class="drag-overlay-content">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="17 8 12 3 7 8"/>
                <line x1="12" x2="12" y1="3" y2="15"/>
            </svg>
            <div>Drop image here to blur faces</div>
        </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
            // Elements
            const imageCanvas = document.getElementById("imageCanvas");
            const ctx = imageCanvas.getContext("2d");
            const imageContainer = document.getElementById("imageContainer");
            const placeholder = document.getElementById("placeholder");
            const processingOverlay = document.getElementById("processingOverlay");
            const dragOverlay = document.getElementById("dragOverlay");
            const errorDisplay = document.getElementById("errorDisplay");

            // Controls
            const imageUpload = document.getElementById("imageUpload");
            const uploadBtn = document.getElementById("uploadBtn");
            const resetBtn = document.getElementById("resetBtn");
            const blurSlider = document.getElementById("blurSlider");
            const blurValue = document.getElementById("blurValue");
            const gaussianRadio = document.getElementById("gaussian");
            const pixelateRadio = document.getElementById("pixelate");
            const autoDetectBtn = document.getElementById("autoDetectBtn");
            const manualSelectBtn = document.getElementById("manualSelectBtn");
            const clearManualBtn = document.getElementById("clearManualBtn");
            const applyBlurBtn = document.getElementById("applyBlurBtn");
            const downloadBtn = document.getElementById("downloadBtn");

            // State
            let originalImage = null;
            let blurRadius = parseInt(blurSlider.value);
            let faces = [];
            let manualBlurAreas = [];
            let isLoadingModels = true;
            let isProcessing = false;
            let blurType = "pixelate";
            let toolMode = "auto-detect";

            // Manual selection
            let isDrawing = false;
            let startPoint = null;
            let currentRect = null;

            const faceapi = window.faceapi;

            // UI State Management
        function updateUIState() {
                const hasImage = originalImage !== null;
                const hasFacesOrManualAreas = faces.length > 0 || manualBlurAreas.length > 0;

                // Button states
                uploadBtn.disabled = isLoadingModels || isProcessing;
                resetBtn.disabled = !hasImage || isProcessing;
                downloadBtn.disabled = !hasImage || isProcessing;
                applyBlurBtn.disabled = !hasImage || isProcessing || !hasFacesOrManualAreas;
                autoDetectBtn.disabled = !hasImage || isProcessing;
                manualSelectBtn.disabled = !hasImage || isProcessing;
                blurSlider.disabled = !hasImage || isProcessing || !hasFacesOrManualAreas;

          // Mode buttons
                if (toolMode === "auto-detect") {
                    autoDetectBtn.classList.remove("btn-secondary");
                    autoDetectBtn.classList.add("btn-primary");
                    manualSelectBtn.classList.remove("btn-primary");
                    manualSelectBtn.classList.add("btn-secondary");
          } else {
                    autoDetectBtn.classList.remove("btn-primary");
                    autoDetectBtn.classList.add("btn-secondary");
                    manualSelectBtn.classList.remove("btn-secondary");
                    manualSelectBtn.classList.add("btn-primary");
                }

                // Clear manual button
                if (toolMode === "manual-select" && manualBlurAreas.length > 0) {
                    clearManualBtn.classList.remove("hidden");
                    clearManualBtn.disabled = isProcessing;
          } else {
                    clearManualBtn.classList.add("hidden");
          }

          // Processing overlay
          if (isProcessing) {
                    processingOverlay.classList.remove("hidden");
          } else {
                    processingOverlay.classList.add("hidden");
          }

          // Upload button text
                uploadBtn.innerHTML = hasImage ? 
                    '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></svg>Change Image' :
                    '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></svg>Upload Image';
            }

            function showError(message) {
                errorDisplay.textContent = message;
                errorDisplay.classList.remove("hidden");
        }

        function clearError() {
                errorDisplay.classList.add("hidden");
        }

            // Load Face API models
        async function loadModels() {
                isLoadingModels = true;
                isProcessing = true;
                clearError();
                updateUIState();

                try {
                    const MODEL_PATH = "https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights";
            await Promise.all([
              faceapi.nets.ssdMobilenetv1.loadFromUri(MODEL_PATH),
              faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_PATH),
                    ]);
                    isLoadingModels = false;
          } catch (err) {
                    console.error("Failed to load face-api models:", err);
                    showError("Failed to load face detection models. Please check your network connection.");
                    isLoadingModels = false;
          } finally {
                    isProcessing = false;
                    updateUIState();
          }
        }

            // Face detection
        async function detectFaces(img) {
                if (!img || isLoadingModels) return [];
                isProcessing = true;
                clearError();
                updateUIState();

                try {
                    const detections = await faceapi.detectAllFaces(img, new faceapi.SsdMobilenetv1Options());
                    return detections;
          } catch (err) {
                    console.error("Face detection failed:", err);
                    showError("Face detection failed. Ensure the image is clear and models are loaded.");
                    return [];
          } finally {
                    isProcessing = false;
                    updateUIState();
          }
        }

            // Canvas drawing
        function drawCanvasContent() {
          if (!originalImage) {
                    ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                    imageCanvas.width = 0;
                    imageCanvas.height = 0;
                    return;
                }

                imageCanvas.width = originalImage.naturalWidth;
                imageCanvas.height = originalImage.naturalHeight;

                ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
                ctx.drawImage(originalImage, 0, 0, imageCanvas.width, imageCanvas.height);

                const regionsToBlur = toolMode === "auto-detect" ? faces.map(d => d.box) : manualBlurAreas;

                regionsToBlur.forEach(box => {
                    const x = Math.max(0, box.x);
                    const y = Math.max(0, box.y);
                    const width = Math.min(box.width, imageCanvas.width - x);
                    const height = Math.min(box.height, imageCanvas.height - y);

                    if (width <= 0 || height <= 0) return;

                    const imageData = ctx.getImageData(x, y, width, height);
                    const tempCanvas = document.createElement("canvas");
                    tempCanvas.width = width;
                    tempCanvas.height = height;
                    const tempCtx = tempCanvas.getContext("2d");
                    tempCtx.putImageData(imageData, 0, 0);

            if (blurType === "gaussian") {
                        tempCtx.filter = `blur(${blurRadius}px)`;
                        tempCtx.drawImage(tempCanvas, 0, 0);
            } else if (blurType === "pixelate") {
                        const pixelSize = Math.max(1, Math.floor(blurRadius / 2));
                        const smallWidth = Math.ceil(width / pixelSize);
                        const smallHeight = Math.ceil(height / pixelSize);

                        tempCtx.imageSmoothingEnabled = false;
                        tempCtx.drawImage(tempCanvas, 0, 0, smallWidth, smallHeight);
                        tempCtx.drawImage(tempCanvas, 0, 0, smallWidth, smallHeight, 0, 0, width, height);
                    }

                    ctx.drawImage(tempCanvas, x, y, width, height);
                });

                // Draw current drawing rectangle
                if (isDrawing && currentRect && toolMode === "manual-select") {
                    ctx.strokeStyle = "rgba(102, 126, 234, 0.8)";
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(currentRect.x, currentRect.y, currentRect.width, currentRect.height);
                    ctx.setLineDash([]);
                }
            }

            // Image loading
        async function loadImage(dataUrl) {
                clearError();
                isProcessing = true;
                updateUIState();

                const img = new Image();
                img.crossOrigin = "anonymous";
          img.onload = async () => {
                    originalImage = img;
                    manualBlurAreas = [];
                    
                    // Show canvas and hide placeholder
                    imageCanvas.classList.remove("hidden");
                    placeholder.classList.add("hidden");
                    imageContainer.classList.add("has-image");
                    
                    if (toolMode === "auto-detect") {
                        faces = await detectFaces(img);
            } else {
                        faces = [];
                    }
                    drawCanvasContent();
                    isProcessing = false;
                    updateUIState();
                };
          img.onerror = () => {
                    showError("Could not load image. Please ensure it's a valid image file.");
                    originalImage = null;
                    faces = [];
                    manualBlurAreas = [];
                    isProcessing = false;
                    updateUIState();
                };
                img.src = dataUrl;
            }

            // URL validation and loading
            function isValidImageUrl(url) {
                try {
                    const urlObj = new URL(url);
                    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.svg'];
                    const pathname = urlObj.pathname.toLowerCase();
                    return imageExtensions.some(ext => pathname.endsWith(ext)) || 
                           url.includes('unsplash.com') || 
                           url.includes('imgur.com') ||
                           url.includes('github.com') ||
                           url.includes('raw.githubusercontent.com');
                } catch {
                    return false;
                }
            }

            async function loadImageFromUrl(url) {
                clearError();
                isProcessing = true;
                updateUIState();
                
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    const blob = await response.blob();
                    const reader = new FileReader();
                    reader.onloadend = () => loadImage(reader.result);
                    reader.readAsDataURL(blob);
                } catch (error) {
                    console.error('Failed to load image from URL:', error);
                    showError(`Failed to load image from URL: ${error.message}`);
                    isProcessing = false;
                    updateUIState();
                }
            }

            // Event Listeners
            uploadBtn.addEventListener("click", () => imageUpload.click());

            imageUpload.addEventListener("change", (event) => {
                const file = event.target.files?.[0];
          if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => loadImage(reader.result);
                    reader.readAsDataURL(file);
                }
            });

            // Global drag and drop
            document.addEventListener("dragover", (event) => {
                event.preventDefault();
                event.dataTransfer.dropEffect = "copy";
            });

            document.addEventListener("dragenter", (event) => {
                event.preventDefault();
                if (event.dataTransfer.types.includes('Files')) {
                    dragOverlay.classList.remove("hidden");
                }
            });

            document.addEventListener("dragleave", (event) => {
                if (!document.contains(event.relatedTarget)) {
                    dragOverlay.classList.add("hidden");
                }
            });

            document.addEventListener("drop", (event) => {
                event.preventDefault();
                dragOverlay.classList.add("hidden");
                const files = event.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        reader.onloadend = () => loadImage(reader.result);
                        reader.readAsDataURL(file);
                    } else {
                        showError("Please drop an image file.");
                    }
                }
            });

            // Paste functionality
        document.addEventListener("paste", (event) => {
                const items = event.clipboardData?.items;
                const text = event.clipboardData?.getData('text');
                
          if (items) {
            for (let i = 0; i < items.length; i++) {
              if (items[i].type.indexOf("image") !== -1) {
                            const blob = items[i].getAsFile();
                if (blob) {
                                const reader = new FileReader();
                                reader.onloadend = () => loadImage(reader.result);
                                reader.readAsDataURL(blob);
                                event.preventDefault();
                                return;
                            }
                        }
                    }
                }
                
                if (text && isValidImageUrl(text)) {
                    loadImageFromUrl(text);
                    event.preventDefault();
                }
            });

            // Reset button
        resetBtn.addEventListener("click", () => {
                originalImage = null;
                faces = [];
                manualBlurAreas = [];
                blurRadius = 20;
                blurSlider.value = 20;
                blurValue.textContent = "20px";
                blurType = "pixelate";
                pixelateRadio.checked = true;
                toolMode = "auto-detect";
                isDrawing = false;
                startPoint = null;
                currentRect = null;
                clearError();
                
                // Hide canvas and show placeholder
                imageCanvas.classList.add("hidden");
                placeholder.classList.remove("hidden");
                imageContainer.classList.remove("has-image");
                
                drawCanvasContent();
                updateUIState();
            });

            // Blur slider
        blurSlider.addEventListener("input", (event) => {
                blurRadius = parseInt(event.target.value);
                blurValue.textContent = blurRadius + "px";
                drawCanvasContent();
            });

            // Blur type radios
        gaussianRadio.addEventListener("change", (event) => {
          if (event.target.checked) {
                    blurType = "gaussian";
                    blurSlider.max = 100;
            if (blurRadius > 100) {
                        blurRadius = 100;
                        blurSlider.value = 100;
                        blurValue.textContent = "100px";
                    }
                    drawCanvasContent();
                }
            });

        pixelateRadio.addEventListener("change", (event) => {
          if (event.target.checked) {
                    blurType = "pixelate";
                    blurSlider.max = 50;
            if (blurRadius > 50) {
                        blurRadius = 50;
                        blurSlider.value = 50;
                        blurValue.textContent = "50px";
                    }
                    drawCanvasContent();
                }
            });

            // Mode buttons
            autoDetectBtn.addEventListener("click", async () => {
                if (toolMode === "auto-detect") return;
                toolMode = "auto-detect";
                manualBlurAreas = [];
                if (originalImage) {
                    faces = await detectFaces(originalImage);
                }
                drawCanvasContent();
                updateUIState();
            });

            manualSelectBtn.addEventListener("click", () => {
                if (toolMode === "manual-select") return;
                toolMode = "manual-select";
                faces = [];
                drawCanvasContent();
                updateUIState();
            });

            // Clear manual selections
            clearManualBtn.addEventListener("click", () => {
                manualBlurAreas = [];
                currentRect = null;
                isDrawing = false;
                drawCanvasContent();
                updateUIState();
            });

            // Apply blur
        applyBlurBtn.addEventListener("click", () => {
          if (originalImage) {
                    drawCanvasContent();
          } else {
                    showError("No image loaded to apply blur.");
          }
            });

            // Download
        downloadBtn.addEventListener("click", () => {
          if (imageCanvas && originalImage) {
                    const link = document.createElement("a");
                    link.download = "blurred-image.png";
                    link.href = imageCanvas.toDataURL("image/png");
                    link.click();
                }
            });

            // Manual selection on canvas
        function getCanvasCoordinates(event) {
                const rect = imageCanvas.getBoundingClientRect();
                const scaleX = imageCanvas.width / rect.width;
                const scaleY = imageCanvas.height / rect.height;
          return {
            x: (event.clientX - rect.left) * scaleX,
            y: (event.clientY - rect.top) * scaleY,
                };
        }

        imageCanvas.addEventListener("mousedown", (event) => {
                if (toolMode !== "manual-select" || !originalImage) return;
                isDrawing = true;
                startPoint = getCanvasCoordinates(event);
                currentRect = null;
            });

        imageCanvas.addEventListener("mousemove", (event) => {
                if (!isDrawing || !startPoint || !originalImage) return;
                const currentPoint = getCanvasCoordinates(event);
                const x = Math.min(startPoint.x, currentPoint.x);
                const y = Math.min(startPoint.y, currentPoint.y);
                const width = Math.abs(startPoint.x - currentPoint.x);
                const height = Math.abs(startPoint.y - currentPoint.y);
                currentRect = { x, y, width, height };
                drawCanvasContent();
            });

        imageCanvas.addEventListener("mouseup", () => {
                if (!isDrawing || !currentRect || !originalImage) return;
                isDrawing = false;
                startPoint = null;
          if (currentRect.width > 0 && currentRect.height > 0) {
                    manualBlurAreas.push(currentRect);
                }
                currentRect = null;
                drawCanvasContent();
                updateUIState();
            });

        imageCanvas.addEventListener("mouseleave", () => {
          if (isDrawing) {
                    imageCanvas.dispatchEvent(new MouseEvent("mouseup"));
                }
            });

            // Initialize
        loadModels().then(() => {
                updateUIState();
            });
        });

      // Initialize Lucide icons
        lucide.createIcons();
    </script>
  </body>
</html>